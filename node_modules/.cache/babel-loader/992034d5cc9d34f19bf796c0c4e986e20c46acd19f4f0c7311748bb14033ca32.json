{"ast":null,"code":"import n, { useState, useCallback } from 'react';\nimport { cx, css } from 'emotion';\nimport { useCombobox } from 'downshift';\nimport { mergeRefs } from '@contentful/f36-core';\nimport { IconButton } from '@contentful/f36-button';\nimport { TextInput } from '@contentful/f36-forms';\nimport { ChevronDownIcon, CloseIcon } from '@contentful/f36-icons';\nimport { Skeleton } from '@contentful/f36-skeleton';\nimport { Popover } from '@contentful/f36-popover';\nimport { Subheading, SectionHeading, Text } from '@contentful/f36-typography';\nimport { getStringMatch } from '@contentful/f36-utils';\nimport p from '@contentful/f36-tokens';\nvar Pe = Object.defineProperty,\n  Me = Object.defineProperties;\nvar Se = Object.getOwnPropertyDescriptors;\nvar M = Object.getOwnPropertySymbols;\nvar q = Object.prototype.hasOwnProperty,\n  z = Object.prototype.propertyIsEnumerable;\nvar W = (e, o, i) => o in e ? Pe(e, o, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: i\n  }) : e[o] = i,\n  d = (e, o) => {\n    for (var i in o || (o = {})) q.call(o, i) && W(e, i, o[i]);\n    if (M) for (var i of M(o)) z.call(o, i) && W(e, i, o[i]);\n    return e;\n  },\n  g = (e, o) => Me(e, Se(o));\nvar j = (e, o) => {\n  var i = {};\n  for (var r in e) q.call(e, r) && o.indexOf(r) < 0 && (i[r] = e[r]);\n  if (e != null && M) for (var r of M(e)) o.indexOf(r) < 0 && z.call(e, r) && (i[r] = e[r]);\n  return i;\n};\nvar S = e => ({\n  autocomplete: css({\n    position: \"relative\",\n    width: \"100%\"\n  }),\n  combobox: css({\n    position: \"relative\"\n  }),\n  inputField: css({\n    paddingRight: p.spacingXl,\n    textOverflow: \"ellipsis\",\n    whiteSpace: \"nowrap\"\n  }),\n  toggleButton: css({\n    position: \"absolute\",\n    top: \"1px\",\n    right: \"1px\",\n    zIndex: 1,\n    padding: p.spacing2Xs,\n    height: \"38px\"\n  }),\n  content: css({\n    overflow: \"auto\",\n    maxHeight: `${e}px`\n  }),\n  list: css({\n    listStyle: \"none\",\n    padding: `${p.spacingXs} 0`,\n    margin: 0\n  }),\n  groupTitle: css({\n    padding: `${p.spacingXs} ${p.spacingM}`,\n    lineHeight: p.lineHeightM\n  }),\n  noMatchesTitle: css({\n    color: p.gray500,\n    margin: `${p.spacingM} 0 ${p.spacingM} 0`\n  }),\n  item: css({\n    display: \"block\",\n    padding: `${p.spacingXs} ${p.spacingM}`,\n    wordBreak: \"break-word\",\n    whiteSpace: \"break-spaces\",\n    cursor: \"pointer\",\n    hyphens: \"auto\",\n    \"&:focus, &:hover\": {\n      backgroundColor: p.gray100\n    },\n    \"&:active\": {\n      backgroundColor: p.gray200\n    }\n  }),\n  disabled: css({\n    opacity: .5,\n    pointerEvents: \"none\"\n  }),\n  highlighted: css({\n    backgroundColor: p.gray100\n  }),\n  hidden: css({\n    display: \"none\"\n  })\n});\nvar C = e => {\n  let {\n      items: o,\n      elementStartIndex: i,\n      highlightedIndex: r,\n      getItemProps: I,\n      renderItem: T,\n      inputValue: b,\n      listMaxHeight: H = 180\n    } = e,\n    s = S(H);\n  return n.createElement(\"ul\", {\n    className: s.list,\n    \"data-test-id\": \"cf-autocomplete-list\"\n  }, o.map((u, E) => {\n    let c = i + E,\n      L = I({\n        item: u,\n        index: c\n      });\n    return n.createElement(Text, g(d({}, L), {\n      as: \"li\",\n      key: c,\n      className: cx([s.item, r === c && s.highlighted]),\n      \"data-test-id\": `cf-autocomplete-list-item-${c}`\n    }), T ? T(u, b) : typeof u == \"string\" ? n.createElement(K, {\n      item: u,\n      inputValue: b\n    }) : u);\n  }));\n};\nC.displayName = \"AutocompleteItems\";\nfunction K({\n  item: e,\n  inputValue: o\n}) {\n  let {\n    before: i,\n    match: r,\n    after: I\n  } = getStringMatch(e, o);\n  return n.createElement(n.Fragment, null, i, n.createElement(\"b\", null, r), I);\n}\nK.displayName = \"HighlightedItem\";\nfunction Re(e, o) {\n  let {\n      id: i,\n      className: r,\n      clearAfterSelect: I = !1,\n      closeAfterSelect: T = !0,\n      defaultValue: b = \"\",\n      selectedItem: H,\n      items: s,\n      onInputValueChange: u,\n      onSelectItem: E,\n      onFocus: c,\n      onBlur: L,\n      renderItem: O,\n      icon: Y = n.createElement(ChevronDownIcon, {\n        variant: \"muted\"\n      }),\n      itemToString: Z = t => t,\n      isInvalid: ee,\n      isDisabled: _,\n      isRequired: te,\n      isReadOnly: oe,\n      showEmptyList: ne,\n      noMatchesMessage: ie = \"No matches found\",\n      placeholder: se = \"Search\",\n      inputRef: re,\n      toggleRef: pe,\n      listRef: le,\n      listWidth: ae = \"auto\",\n      listMaxHeight: me = 180,\n      isGrouped: x = !1,\n      isLoading: v = !1,\n      usePortal: ue = !1,\n      testId: ce = \"cf-autocomplete\"\n    } = e,\n    m = S(me),\n    [h, de] = useState(b),\n    y = useCallback(t => {\n      de(t), u == null || u(t);\n    }, [u]),\n    ge = useCallback(t => {\n      let l = t.target.value;\n      y(l);\n    }, [y]),\n    he = A(x) ? s.reduce((t, l) => [...t, ...l.options], []) : s,\n    fe = A(x) ? s.every(t => t.options.length === 0) : s.length === 0,\n    {\n      getComboboxProps: Ie,\n      getInputProps: ye,\n      getItemProps: $,\n      getMenuProps: Te,\n      getToggleButtonProps: be,\n      highlightedIndex: D,\n      isOpen: F,\n      toggleMenu: k\n    } = useCombobox({\n      items: he,\n      selectedItem: H,\n      inputValue: h,\n      itemToString: Z,\n      onInputValueChange: ({\n        type: t,\n        inputValue: l\n      }) => {\n        t !== \"__input_change__\" && y(l);\n      },\n      onStateChange: ({\n        type: t,\n        selectedItem: l\n      }) => {\n        switch (t) {\n          case useCombobox.stateChangeTypes.InputKeyDownEnter:\n          case useCombobox.stateChangeTypes.ItemClick:\n            l && E(l), I && y(\"\"), T || k();\n            break;\n        }\n      }\n    }),\n    U = ye(),\n    w = j(U, [\"aria-labelledby\", \"id\"]),\n    xe = Ie(),\n    X = be(),\n    P = Te(),\n    N = 0;\n  return n.createElement(\"div\", {\n    \"data-test-id\": ce,\n    className: cx(m.autocomplete, r),\n    ref: o\n  }, n.createElement(Popover, {\n    usePortal: ue,\n    isOpen: F,\n    isFullWidth: ae === \"full\",\n    renderOnlyWhenOpen: !1,\n    autoFocus: !1,\n    id: P.id\n  }, n.createElement(Popover.Trigger, null, n.createElement(\"div\", g(d({}, xe), {\n    className: m.combobox\n  }), n.createElement(TextInput, g(d({\n    className: m.inputField\n  }, w), {\n    onFocus: t => {\n      c == null || c(t), F || k();\n    },\n    onBlur: L,\n    id: i,\n    isInvalid: ee,\n    isDisabled: _,\n    isRequired: te,\n    isReadOnly: oe,\n    ref: mergeRefs(w.ref, re),\n    testId: \"cf-autocomplete-input\",\n    placeholder: se,\n    onChange: t => {\n      w.onChange(t), ge(t);\n    }\n  })), n.createElement(IconButton, g(d({}, X), {\n    ref: mergeRefs(X.ref, pe),\n    \"aria-label\": h ? \"Clear\" : \"Show list\",\n    className: m.toggleButton,\n    variant: \"transparent\",\n    icon: h ? n.createElement(CloseIcon, {\n      variant: \"muted\"\n    }) : Y,\n    onClick: () => {\n      h ? y(\"\") : k();\n    },\n    isDisabled: _,\n    size: \"small\"\n  })))), s.length > 0 || h.length > 0 || ne ? n.createElement(Popover.Content, g(d({}, P), {\n    ref: mergeRefs(P.ref, le),\n    className: m.content,\n    testId: \"cf-autocomplete-container\"\n  }), v && [...Array(3)].map((t, l) => n.createElement(\"div\", {\n    key: l,\n    className: cx(m.item, m.disabled)\n  }, n.createElement(Be, null))), !v && fe && n.createElement(\"div\", {\n    className: m.item\n  }, n.createElement(Subheading, {\n    className: m.noMatchesTitle\n  }, ie)), !v && A(x) && s.map((t, l) => {\n    if (t.options.length < 1) return;\n    let ve = n.createElement(\"div\", {\n      key: l\n    }, n.createElement(SectionHeading, {\n      key: l,\n      \"data-test-id\": \"cf-autocomplete-grouptitle\",\n      marginBottom: \"none\",\n      className: m.groupTitle\n    }, t.groupTitle), n.createElement(C, {\n      items: t.options,\n      highlightedIndex: D,\n      getItemProps: $,\n      renderItem: O,\n      inputValue: h,\n      elementStartIndex: N\n    }));\n    return N += t.options.length, ve;\n  }), !v && !A(x) && s.length > 0 && n.createElement(C, {\n    items: s,\n    elementStartIndex: N,\n    highlightedIndex: D,\n    getItemProps: $,\n    renderItem: O,\n    inputValue: h\n  })) : n.createElement(\"div\", g(d({}, P), {\n    className: cx(m.hidden)\n  }))));\n}\nvar Be = () => n.createElement(Skeleton.Container, {\n  svgHeight: 16\n}, n.createElement(Skeleton.BodyText, {\n  numberOfLines: 1\n}));\nfunction A(e, o) {\n  return e;\n}\nvar Oe = n.forwardRef(Re);\nexport { Oe as Autocomplete };","map":{"version":3,"names":[],"sources":["/Users/markhuntley/Code/contentful-integration/split/node_modules/@contentful/f36-autocomplete/src/Autocomplete.tsx","/Users/markhuntley/Code/contentful-integration/split/node_modules/@contentful/f36-autocomplete/src/AutocompleteItems.tsx","/Users/markhuntley/Code/contentful-integration/split/node_modules/@contentful/f36-autocomplete/src/Autocomplete.styles.ts"],"sourcesContent":["import React, { useCallback, useState } from 'react';\nimport { cx } from 'emotion';\nimport { useCombobox } from 'downshift';\n\nimport {\n  mergeRefs,\n  type CommonProps,\n  type ExpandProps,\n} from '@contentful/f36-core';\nimport { IconButton } from '@contentful/f36-button';\nimport { TextInput, type TextInputProps } from '@contentful/f36-forms';\nimport { CloseIcon, ChevronDownIcon } from '@contentful/f36-icons';\nimport { Skeleton } from '@contentful/f36-skeleton';\nimport { Popover } from '@contentful/f36-popover';\nimport { Subheading, SectionHeading } from '@contentful/f36-typography';\n\nimport { AutocompleteItems } from './AutocompleteItems';\nimport { getAutocompleteStyles } from './Autocomplete.styles';\n\nexport interface GenericGroupType<ItemType> {\n  groupTitle: string;\n  options: ItemType[];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface AutocompleteProps<ItemType>\n  extends CommonProps,\n    Pick<\n      TextInputProps,\n      | 'isDisabled'\n      | 'isInvalid'\n      | 'isReadOnly'\n      | 'isRequired'\n      | 'id'\n      | 'defaultValue'\n    > {\n  /**\n   * It’s an array of data to be used as \"options\" by the autocomplete component.\n   * This can either be a plain list of items or a list of groups of items.\n   */\n  items: ItemType[] | GenericGroupType<ItemType>[];\n\n  /**\n   * Set a custom icon for the text input\n   */\n  icon?: React.ReactElement;\n\n  /**\n   * Tells if the item is a object with groups\n   */\n  isGrouped?: boolean;\n\n  /**\n   * Function called whenever the input value changes\n   */\n  onInputValueChange?: (value: string) => void;\n  /**\n   * This is the function that will be called when the user selects one of the \"options\" in the list.\n   * The component will pass the selected \"item\" as an argument to the function..\n   */\n  onSelectItem: (item: ItemType) => void;\n\n  /**\n   * Applying the selectedItem property turns autocomplete into a controlled component.\n   * Can be used to display e.g. previously selected element. If it is an object the itemToString function will apply to it.\n   */\n  selectedItem?: ItemType;\n\n  /**\n   * This is the function that will be called for each \"item\" passed in the `items` prop.\n   * It receives the \"item\" and \"inputValue\" as arguments and returns a ReactNode.\n   * The inputValue is passed in case you want to highlight the match on the render.\n   */\n  renderItem?: (item: ItemType, inputValue: string) => React.ReactNode;\n  /**\n   * When using objects as `items`, we recommend passing a function that tells Downshift how to extract a string\n   * from those objetcs to be used as inputValue\n   */\n  itemToString?: (item: ItemType) => string;\n  /**\n   * If this is set to `true` the text input will be cleared after an item is selected\n   * @default false\n   */\n  clearAfterSelect?: boolean;\n  /**\n   * If this is set to `false` the dropdown menu will stay open after selecting an item\n   * @default true\n   */\n  closeAfterSelect?: boolean;\n  /**\n   * This is the value will be passed to the `placeholder` prop of the input.\n   * @default \"Search\"\n   */\n  placeholder?: string;\n  /**\n   * Defines if the list should be shown even if empty, when input is focused\n   * @default false\n   */\n  showEmptyList?: boolean;\n  /**\n   * A message that will be shown when it is not possible to find any option that matches the input value\n   * @default \"No matches\"\n   */\n  noMatchesMessage?: string;\n  /**\n   * Use this prop to get a ref to the input element of the component\n   */\n  inputRef?: React.Ref<HTMLInputElement>;\n  /**\n   * Use this prop to get a ref to the toggle button of the component\n   */\n  toggleRef?: React.Ref<HTMLButtonElement>;\n  /**\n   * Use this prop to get a ref to the list of items of the component\n   */\n  listRef?: React.Ref<HTMLUListElement>;\n  /**\n   * It sets the width of the list\n   * @default \"auto\"\n   */\n  listWidth?: 'auto' | 'full';\n  /**\n   * It sets the max-height, in pixels, of the list\n   * The default value is the height of 5 single line items\n   * @default 180\n   */\n  listMaxHeight?: number;\n  /**\n   * Sets the list to show its loading state\n   * @default false\n   */\n  isLoading?: boolean;\n  /**\n   * Boolean to control whether or not to render the suggestions box in a React Portal.\n   * Rendering content inside a Portal allows the suggestions box to escape the bounds\n   * of its parent while still being positioned correctly.\n   * Defaults to `false`\n   */\n  usePortal?: boolean;\n\n  /**\n   * Function called when the input is focused\n   *\n   * @param event\n   */\n  onFocus?: (event: React.FocusEvent<HTMLInputElement>) => void;\n  /**\n   * Function called when the input is blurred\n   * @param event\n   */\n  onBlur?: (event: React.FocusEvent<HTMLInputElement>) => void;\n}\n\nfunction _Autocomplete<ItemType>(\n  props: AutocompleteProps<ItemType>,\n  ref: React.Ref<HTMLDivElement>,\n) {\n  const {\n    id,\n    className,\n    clearAfterSelect = false,\n    closeAfterSelect = true,\n    defaultValue = '',\n    selectedItem,\n    items,\n    onInputValueChange,\n    onSelectItem,\n    onFocus,\n    onBlur,\n    renderItem,\n    icon = <ChevronDownIcon variant=\"muted\" />,\n    itemToString = (item: ItemType) => item as unknown as string,\n    isInvalid,\n    isDisabled,\n    isRequired,\n    isReadOnly,\n    showEmptyList,\n    noMatchesMessage = 'No matches found',\n    placeholder = 'Search',\n    inputRef,\n    toggleRef,\n    listRef,\n    listWidth = 'auto',\n    listMaxHeight = 180,\n    isGrouped = false,\n    isLoading = false,\n    usePortal = false,\n    testId = 'cf-autocomplete',\n  } = props;\n\n  type GroupType = GenericGroupType<ItemType>;\n\n  const styles = getAutocompleteStyles(listMaxHeight);\n\n  const [inputValue, setInputValue] = useState(defaultValue);\n\n  const handleInputValueChange = useCallback(\n    (value: string) => {\n      setInputValue(value);\n\n      onInputValueChange?.(value);\n    },\n    [onInputValueChange],\n  );\n\n  // Handle manually to avoid a jumping cursor, see https://github.com/downshift-js/downshift/issues/1108#issuecomment-842407759\n  const handleNativeChangeEvent = useCallback(\n    (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n      const value = event.target.value;\n      handleInputValueChange(value);\n    },\n    [handleInputValueChange],\n  );\n\n  const flattenItems = isUsingGroups(isGrouped, items)\n    ? items.reduce(\n        (acc: ItemType[], group: GroupType) => [...acc, ...group.options],\n        [],\n      )\n    : items;\n\n  const isShowingNoMatches = isUsingGroups(isGrouped, items)\n    ? items.every((group: GroupType) => group.options.length === 0)\n    : items.length === 0;\n\n  const {\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getMenuProps,\n    getToggleButtonProps,\n    highlightedIndex,\n    isOpen,\n    toggleMenu,\n  } = useCombobox({\n    items: flattenItems,\n    selectedItem,\n    inputValue,\n    itemToString,\n    onInputValueChange: ({ type, inputValue }) => {\n      if (type !== '__input_change__') {\n        handleInputValueChange(inputValue);\n      }\n    },\n    onStateChange: ({ type, selectedItem }) => {\n      switch (type) {\n        case useCombobox.stateChangeTypes.InputKeyDownEnter:\n        case useCombobox.stateChangeTypes.ItemClick:\n          if (selectedItem) {\n            onSelectItem(selectedItem);\n          }\n          if (clearAfterSelect) {\n            handleInputValueChange('');\n          }\n          if (!closeAfterSelect) {\n            toggleMenu();\n          }\n          break;\n        default:\n          break;\n      }\n    },\n  });\n\n  const {\n    'aria-labelledby': _labelledby,\n    id: _inputId,\n    ...inputProps\n  } = getInputProps();\n  const comboboxProps = getComboboxProps();\n  const toggleProps = getToggleButtonProps();\n  const menuProps = getMenuProps();\n  let elementStartIndex = 0;\n\n  return (\n    <div\n      data-test-id={testId}\n      className={cx(styles.autocomplete, className)}\n      ref={ref}\n    >\n      <Popover\n        usePortal={usePortal}\n        isOpen={isOpen}\n        isFullWidth={listWidth === 'full'}\n        renderOnlyWhenOpen={false}\n        // This is necessary, otherwise the focus will change from the input to the Popover\n        // and the user won't be able to type in the input\n        // eslint-disable-next-line jsx-a11y/no-autofocus\n        autoFocus={false}\n        id={menuProps.id}\n      >\n        <Popover.Trigger>\n          <div {...comboboxProps} className={styles.combobox}>\n            <TextInput\n              className={styles.inputField}\n              {...inputProps}\n              onFocus={(e) => {\n                onFocus?.(e as React.FocusEvent<HTMLInputElement>);\n                if (!isOpen) {\n                  toggleMenu();\n                }\n              }}\n              onBlur={onBlur}\n              id={id}\n              isInvalid={isInvalid}\n              isDisabled={isDisabled}\n              isRequired={isRequired}\n              isReadOnly={isReadOnly}\n              ref={mergeRefs(inputProps.ref, inputRef)}\n              testId=\"cf-autocomplete-input\"\n              placeholder={placeholder}\n              onChange={(event) => {\n                inputProps.onChange(event);\n                handleNativeChangeEvent(event);\n              }}\n            />\n            <IconButton\n              {...toggleProps}\n              ref={mergeRefs(toggleProps.ref, toggleRef)}\n              aria-label={inputValue ? 'Clear' : 'Show list'}\n              className={styles.toggleButton}\n              variant=\"transparent\"\n              icon={inputValue ? <CloseIcon variant=\"muted\" /> : icon}\n              onClick={() => {\n                if (inputValue) {\n                  handleInputValueChange('');\n                } else {\n                  toggleMenu();\n                }\n              }}\n              isDisabled={isDisabled}\n              size=\"small\"\n            />\n          </div>\n        </Popover.Trigger>\n\n        {items.length > 0 || inputValue.length > 0 || showEmptyList ? (\n          <Popover.Content\n            {...menuProps}\n            ref={mergeRefs(menuProps.ref, listRef)}\n            className={styles.content}\n            testId=\"cf-autocomplete-container\"\n          >\n            {isLoading &&\n              [...Array(3)].map((_, index) => (\n                <div key={index} className={cx(styles.item, styles.disabled)}>\n                  <ListItemLoadingState />\n                </div>\n              ))}\n\n            {!isLoading && isShowingNoMatches && (\n              <div className={styles.item}>\n                <Subheading className={styles.noMatchesTitle}>\n                  {noMatchesMessage}\n                </Subheading>\n              </div>\n            )}\n\n            {!isLoading &&\n              isUsingGroups(isGrouped, items) &&\n              items.map((group: GroupType, index: number) => {\n                if (group.options.length < 1) {\n                  return;\n                }\n                const render = (\n                  <div key={index}>\n                    <SectionHeading\n                      key={index}\n                      data-test-id=\"cf-autocomplete-grouptitle\"\n                      marginBottom=\"none\"\n                      className={styles.groupTitle}\n                    >\n                      {group.groupTitle}\n                    </SectionHeading>\n                    <AutocompleteItems<ItemType>\n                      items={group.options}\n                      highlightedIndex={highlightedIndex}\n                      getItemProps={getItemProps}\n                      renderItem={renderItem}\n                      inputValue={inputValue}\n                      elementStartIndex={elementStartIndex}\n                    />\n                  </div>\n                );\n                elementStartIndex += group.options.length;\n                return render;\n              })}\n\n            {!isLoading &&\n              !isUsingGroups(isGrouped, items) &&\n              items.length > 0 && (\n                <AutocompleteItems<ItemType>\n                  items={items}\n                  elementStartIndex={elementStartIndex}\n                  highlightedIndex={highlightedIndex}\n                  getItemProps={getItemProps}\n                  renderItem={renderItem}\n                  inputValue={inputValue}\n                />\n              )}\n          </Popover.Content>\n        ) : (\n          // We need to render an empty hidden div, so we can pass the menuProps or downshift will show a warning about it\n          // https://github.com/downshift-js/downshift/issues/1167#issuecomment-1088022842\n          <div {...menuProps} className={cx(styles.hidden)} />\n        )}\n      </Popover>\n    </div>\n  );\n}\n\nconst ListItemLoadingState = () => {\n  return (\n    <Skeleton.Container svgHeight={16}>\n      <Skeleton.BodyText numberOfLines={1} />\n    </Skeleton.Container>\n  );\n};\n\n// This is required to infer correct typings when differentiating groups and items\nfunction isUsingGroups<ItemType>(\n  isGrouped: boolean,\n  items: ItemType[] | GenericGroupType<ItemType>[],\n): items is GenericGroupType<ItemType>[] {\n  return isGrouped;\n}\n\n/**\n * The Autocomplete is a component that will show a `TextInput` where a user can type any word which will be used\n * to filter a list of items. That list of filtered items will be shown to the user as possible options for the input.\n * Once one of the options is selected, that option becomes the value of the `TextInput`.\n */\nexport const Autocomplete = React.forwardRef(_Autocomplete) as <T>(\n  props: ExpandProps<AutocompleteProps<T>> & {\n    ref?: React.Ref<HTMLDivElement>;\n  },\n) => ReturnType<typeof _Autocomplete>;\n","import React, { HTMLAttributes } from 'react';\nimport { cx } from 'emotion';\nimport { getStringMatch } from '@contentful/f36-utils';\nimport type { UseComboboxGetItemPropsOptions } from 'downshift';\nimport { Text } from '@contentful/f36-typography';\n\nimport { getAutocompleteStyles } from './Autocomplete.styles';\n\ninterface AutocompleteItemsProps<ItemType> {\n  items: ItemType[];\n  elementStartIndex: number;\n  highlightedIndex: number;\n  getItemProps: (\n    options: UseComboboxGetItemPropsOptions<ItemType>,\n  ) => HTMLAttributes<HTMLLIElement>;\n  renderItem: (item: ItemType, inputValue: string) => React.ReactNode;\n  inputValue: string;\n  listMaxHeight?: number;\n}\n\nexport const AutocompleteItems = <ItemType,>(\n  props: AutocompleteItemsProps<ItemType>,\n) => {\n  const {\n    items,\n    elementStartIndex,\n    highlightedIndex,\n    getItemProps,\n    renderItem,\n    inputValue,\n    listMaxHeight = 180,\n  } = props;\n\n  const styles = getAutocompleteStyles(listMaxHeight);\n\n  return (\n    <ul className={styles.list} data-test-id=\"cf-autocomplete-list\">\n      {items.map((item: ItemType, index: number) => {\n        const itemIndex = elementStartIndex + index;\n        const itemProps = getItemProps({ item, index: itemIndex });\n        return (\n          <Text\n            {...itemProps}\n            as=\"li\"\n            key={itemIndex}\n            className={cx([\n              styles.item,\n              highlightedIndex === itemIndex && styles.highlighted,\n            ])}\n            data-test-id={`cf-autocomplete-list-item-${itemIndex}`}\n          >\n            {renderItem ? (\n              renderItem(item, inputValue)\n            ) : typeof item === 'string' ? (\n              <HighlightedItem item={item} inputValue={inputValue} />\n            ) : (\n              item\n            )}\n          </Text>\n        );\n      })}\n    </ul>\n  );\n};\n\nAutocompleteItems.displayName = 'AutocompleteItems';\n\nfunction HighlightedItem({\n  item,\n  inputValue,\n}: {\n  item: string;\n  inputValue: string;\n}) {\n  const { before, match, after } = getStringMatch(item, inputValue);\n\n  return (\n    <>\n      {before}\n      <b>{match}</b>\n      {after}\n    </>\n  );\n}\n\nHighlightedItem.displayName = 'HighlightedItem';\n","import { css } from 'emotion';\nimport tokens from '@contentful/f36-tokens';\n\nexport const getAutocompleteStyles = (listMaxHeight: number) => ({\n  autocomplete: css({\n    position: 'relative',\n    width: '100%',\n  }),\n  combobox: css({\n    position: 'relative',\n  }),\n  inputField: css({\n    paddingRight: tokens.spacingXl,\n    textOverflow: 'ellipsis',\n    whiteSpace: 'nowrap',\n  }),\n  toggleButton: css({\n    position: 'absolute',\n    top: '1px',\n    right: '1px',\n    zIndex: 1,\n    padding: tokens.spacing2Xs,\n    height: '38px',\n  }),\n  content: css({\n    overflow: 'auto',\n    maxHeight: `${listMaxHeight}px`,\n  }),\n  list: css({\n    listStyle: 'none',\n    padding: `${tokens.spacingXs} 0`,\n    margin: 0,\n  }),\n  groupTitle: css({\n    padding: `${tokens.spacingXs} ${tokens.spacingM}`,\n    lineHeight: tokens.lineHeightM,\n  }),\n  noMatchesTitle: css({\n    color: tokens.gray500,\n    margin: `${tokens.spacingM} 0 ${tokens.spacingM} 0`,\n  }),\n  item: css({\n    display: 'block',\n    padding: `${tokens.spacingXs} ${tokens.spacingM}`,\n    wordBreak: 'break-word',\n    whiteSpace: 'break-spaces',\n    cursor: 'pointer',\n    hyphens: 'auto',\n\n    '&:focus, &:hover': {\n      backgroundColor: tokens.gray100,\n    },\n    '&:active': {\n      backgroundColor: tokens.gray200,\n    },\n  }),\n  disabled: css({\n    opacity: 0.5,\n    pointerEvents: 'none',\n  }),\n  highlighted: css({\n    backgroundColor: tokens.gray100,\n  }),\n  hidden: css({\n    display: 'none',\n  }),\n});\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}